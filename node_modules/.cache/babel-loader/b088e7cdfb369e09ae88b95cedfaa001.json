{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { isNotEmptyObject } from '.';\n\nfunction UseHeaderchange(newPath, newHeaderType, ...rest) {\n  _s();\n\n  if (!window['newMemory']) {\n    window['newMemory'] = {};\n    console.log('new memory', window['newMemory']);\n  }\n\n  const {\n    newMemory\n  } = window;\n  const [filters, setFilters] = useState({});\n  const initialState = {\n    path: newPath,\n    headerType: newHeaderType || 'home',\n    ...rest\n  };\n\n  if (!isNotEmptyObject(filters)) {\n    setFilters({ ...initialState\n    });\n  } // if (!newMemory[newPath]) newMemory[newPath] = { ...initialState };\n\n\n  let handleMemoryChange = useCallback(() => {\n    const {\n      path,\n      headerType\n    } = filters;\n\n    if (!newMemory[newPath]) {\n      newMemory[newPath] = { ...initialState\n      }; // setFilters({\n      //     ...filters,\n      //     path: newPath,\n      //     headerType: newHeaderType || 'home'\n      // })\n\n      setFilters({ ...initialState\n      });\n      console.log(newMemory, initialState, 'state');\n    } else {\n      console.log(newMemory, filters, 'state', '1');\n      return filters;\n    }\n  }, [filters]);\n  useEffect(() => {\n    window.addEventListener('memoryChange', handleMemoryChange);\n    window.removeEventListener('memoryChange', handleMemoryChange);\n  }, [filters]);\n  console.log(newMemory, filters, 'state', '2');\n  return filters;\n}\n\n_s(UseHeaderchange, \"An1g4kfC8XbKtJDtYS2/NPWOa9Y=\");\n\n_c = UseHeaderchange;\nUseHeaderchange.propTypes = {\n  newPath: PropTypes.string,\n  headerType: PropTypes.string\n};\nexport default UseHeaderchange;\n\nvar _c;\n\n$RefreshReg$(_c, \"UseHeaderchange\");","map":{"version":3,"sources":["/home/hestabit/Music/moonick/src/utils/global-functions/use-Header-change.js"],"names":["React","useState","useEffect","useCallback","PropTypes","isNotEmptyObject","UseHeaderchange","newPath","newHeaderType","rest","window","console","log","newMemory","filters","setFilters","initialState","path","headerType","handleMemoryChange","addEventListener","removeEventListener","propTypes","string"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,QAAwD,OAAxD;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,SAASC,gBAAT,QAAiC,GAAjC;;AAEA,SAASC,eAAT,CAAyBC,OAAzB,EAAkCC,aAAlC,EAAiD,GAAGC,IAApD,EAA0D;AAAA;;AACtD,MAAI,CAACC,MAAM,CAAC,WAAD,CAAX,EAA0B;AACtBA,IAAAA,MAAM,CAAC,WAAD,CAAN,GAAsB,EAAtB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BF,MAAM,CAAC,WAAD,CAAhC;AACH;;AAED,QAAM;AAAEG,IAAAA;AAAF,MAAgBH,MAAtB;AAEA,QAAM,CAACI,OAAD,EAAUC,UAAV,IAAwBd,QAAQ,CAAC,EAAD,CAAtC;AAEA,QAAMe,YAAY,GAAG;AACjBC,IAAAA,IAAI,EAAEV,OADW;AAEjBW,IAAAA,UAAU,EAAEV,aAAa,IAAI,MAFZ;AAGjB,OAAGC;AAHc,GAArB;;AAMA,MAAG,CAACJ,gBAAgB,CAACS,OAAD,CAApB,EAA+B;AAC3BC,IAAAA,UAAU,CAAC,EAAE,GAAGC;AAAL,KAAD,CAAV;AACH,GAlBqD,CAoBtD;;;AAEA,MAAIG,kBAAkB,GAAGhB,WAAW,CAAC,MAAM;AACvC,UAAM;AAAEc,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAuBJ,OAA7B;;AACA,QAAI,CAACD,SAAS,CAACN,OAAD,CAAd,EAAyB;AACrBM,MAAAA,SAAS,CAACN,OAAD,CAAT,GAAqB,EAAE,GAAGS;AAAL,OAArB,CADqB,CAErB;AACA;AACA;AACA;AACA;;AACAD,MAAAA,UAAU,CAAC,EAAE,GAAGC;AAAL,OAAD,CAAV;AACAL,MAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAAuBG,YAAvB,EAAqC,OAArC;AACH,KATD,MASO;AACHL,MAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAAuBC,OAAvB,EAAgC,OAAhC,EAAyC,GAAzC;AACA,aAAOA,OAAP;AACH;AACJ,GAfmC,EAejC,CAACA,OAAD,CAfiC,CAApC;AAiBAZ,EAAAA,SAAS,CAAC,MAAM;AACZQ,IAAAA,MAAM,CAACU,gBAAP,CAAwB,cAAxB,EAAwCD,kBAAxC;AACAT,IAAAA,MAAM,CAACW,mBAAP,CAA2B,cAA3B,EAA2CF,kBAA3C;AACH,GAHQ,EAGN,CAACL,OAAD,CAHM,CAAT;AAIAH,EAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAAuBC,OAAvB,EAAgC,OAAhC,EAAyC,GAAzC;AACA,SAAOA,OAAP;AACH;;GA7CQR,e;;KAAAA,e;AA+CTA,eAAe,CAACgB,SAAhB,GAA4B;AACxBf,EAAAA,OAAO,EAAEH,SAAS,CAACmB,MADK;AAExBL,EAAAA,UAAU,EAAEd,SAAS,CAACmB;AAFE,CAA5B;AAKA,eAAejB,eAAf","sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { isNotEmptyObject } from '.';\n\nfunction UseHeaderchange(newPath, newHeaderType, ...rest) {\n    if (!window['newMemory']) {\n        window['newMemory'] = {};\n        console.log('new memory', window['newMemory']);\n    }\n\n    const { newMemory } = window;\n\n    const [filters, setFilters] = useState({});\n\n    const initialState = {\n        path: newPath,\n        headerType: newHeaderType || 'home',\n        ...rest\n    };\n\n    if(!isNotEmptyObject(filters)) {\n        setFilters({ ...initialState });\n    }    \n\n    // if (!newMemory[newPath]) newMemory[newPath] = { ...initialState };\n\n    let handleMemoryChange = useCallback(() => {\n        const { path, headerType } = filters;\n        if (!newMemory[newPath]) {\n            newMemory[newPath] = { ...initialState };\n            // setFilters({\n            //     ...filters,\n            //     path: newPath,\n            //     headerType: newHeaderType || 'home'\n            // })\n            setFilters({ ...initialState });\n            console.log(newMemory, initialState, 'state');\n        } else {\n            console.log(newMemory, filters, 'state', '1');\n            return filters;\n        }\n    }, [filters])\n\n    useEffect(() => {\n        window.addEventListener('memoryChange', handleMemoryChange)\n        window.removeEventListener('memoryChange', handleMemoryChange)\n    }, [filters])\n    console.log(newMemory, filters, 'state', '2');\n    return filters;\n}\n\nUseHeaderchange.propTypes = {\n    newPath: PropTypes.string,\n    headerType: PropTypes.string\n}\n\nexport default UseHeaderchange;"]},"metadata":{},"sourceType":"module"}