{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { isNotEmptyObject } from '.';\n\nfunction UseHeaderchange(newPath, newHeaderType, ...rest) {\n  _s();\n\n  if (!window['newMemory']) {\n    window['newMemory'] = {};\n    console.log('new memory', window['newMemory']);\n  }\n\n  const {\n    newMemory\n  } = window; // const [filters, setFilters] = useState({});\n\n  const initialState = {\n    path: newPath,\n    headerType: newHeaderType || 'home',\n    ...rest\n  }; // if(!isNotEmptyObject(filters)) {\n  //     setFilters({ ...initialState });\n  // }    \n  // if (!newMemory[newPath]) newMemory[newPath] = { ...initialState };\n\n  let handleMemoryChange = useCallback(() => {\n    const {\n      path,\n      headerType\n    } = filters;\n\n    if (!newMemory[newPath]) {\n      newMemory[newPath] = { ...initialState\n      }; // setFilters({\n      //     ...filters,\n      //     path: newPath,\n      //     headerType: newHeaderType || 'home'\n      // })\n      // setFilters({ ...initialState });\n\n      console.log(newMemory, initialState, 'state');\n    } else {\n      console.log(newMemory, 'state', '1');\n      return {};\n    }\n  }, []);\n  useEffect(() => {\n    window.addEventListener('memoryChange', handleMemoryChange);\n    window.removeEventListener('memoryChange', handleMemoryChange);\n  }, []);\n  console.log(newMemory, 'state', '2');\n  return;\n}\n\n_s(UseHeaderchange, \"KhmZyS3We4vNPklBypeOLqYJgdU=\");\n\n_c = UseHeaderchange;\nUseHeaderchange.propTypes = {\n  newPath: PropTypes.string,\n  headerType: PropTypes.string\n};\nexport default UseHeaderchange;\n\nvar _c;\n\n$RefreshReg$(_c, \"UseHeaderchange\");","map":{"version":3,"sources":["/home/hestabit/Music/moonick/src/utils/global-functions/use-Header-change.js"],"names":["React","useState","useEffect","useCallback","PropTypes","isNotEmptyObject","UseHeaderchange","newPath","newHeaderType","rest","window","console","log","newMemory","initialState","path","headerType","handleMemoryChange","filters","addEventListener","removeEventListener","propTypes","string"],"mappings":";;AAAA,OAAOA,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,EAAqCC,WAArC,QAAwD,OAAxD;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,SAASC,gBAAT,QAAiC,GAAjC;;AAEA,SAASC,eAAT,CAAyBC,OAAzB,EAAkCC,aAAlC,EAAiD,GAAGC,IAApD,EAA0D;AAAA;;AACtD,MAAI,CAACC,MAAM,CAAC,WAAD,CAAX,EAA0B;AACtBA,IAAAA,MAAM,CAAC,WAAD,CAAN,GAAsB,EAAtB;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BF,MAAM,CAAC,WAAD,CAAhC;AACH;;AAED,QAAM;AAAEG,IAAAA;AAAF,MAAgBH,MAAtB,CANsD,CAQtD;;AAEA,QAAMI,YAAY,GAAG;AACjBC,IAAAA,IAAI,EAAER,OADW;AAEjBS,IAAAA,UAAU,EAAER,aAAa,IAAI,MAFZ;AAGjB,OAAGC;AAHc,GAArB,CAVsD,CAgBtD;AACA;AACA;AAEA;;AAEA,MAAIQ,kBAAkB,GAAGd,WAAW,CAAC,MAAM;AACvC,UAAM;AAAEY,MAAAA,IAAF;AAAQC,MAAAA;AAAR,QAAuBE,OAA7B;;AACA,QAAI,CAACL,SAAS,CAACN,OAAD,CAAd,EAAyB;AACrBM,MAAAA,SAAS,CAACN,OAAD,CAAT,GAAqB,EAAE,GAAGO;AAAL,OAArB,CADqB,CAErB;AACA;AACA;AACA;AACA;AACA;;AACAH,MAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAAuBC,YAAvB,EAAqC,OAArC;AACH,KATD,MASO;AACHH,MAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAAuB,OAAvB,EAAgC,GAAhC;AACA,aAAO,EAAP;AACH;AACJ,GAfmC,EAejC,EAfiC,CAApC;AAiBAX,EAAAA,SAAS,CAAC,MAAM;AACZQ,IAAAA,MAAM,CAACS,gBAAP,CAAwB,cAAxB,EAAwCF,kBAAxC;AACAP,IAAAA,MAAM,CAACU,mBAAP,CAA2B,cAA3B,EAA2CH,kBAA3C;AACH,GAHQ,EAGN,EAHM,CAAT;AAIAN,EAAAA,OAAO,CAACC,GAAR,CAAYC,SAAZ,EAAuB,OAAvB,EAAgC,GAAhC;AACA;AACH;;GA7CQP,e;;KAAAA,e;AA+CTA,eAAe,CAACe,SAAhB,GAA4B;AACxBd,EAAAA,OAAO,EAAEH,SAAS,CAACkB,MADK;AAExBN,EAAAA,UAAU,EAAEZ,SAAS,CAACkB;AAFE,CAA5B;AAKA,eAAehB,eAAf","sourcesContent":["import React, { useState, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nimport { isNotEmptyObject } from '.';\n\nfunction UseHeaderchange(newPath, newHeaderType, ...rest) {\n    if (!window['newMemory']) {\n        window['newMemory'] = {};\n        console.log('new memory', window['newMemory']);\n    }\n\n    const { newMemory } = window;\n\n    // const [filters, setFilters] = useState({});\n\n    const initialState = {\n        path: newPath,\n        headerType: newHeaderType || 'home',\n        ...rest\n    };\n\n    // if(!isNotEmptyObject(filters)) {\n    //     setFilters({ ...initialState });\n    // }    \n\n    // if (!newMemory[newPath]) newMemory[newPath] = { ...initialState };\n\n    let handleMemoryChange = useCallback(() => {\n        const { path, headerType } = filters;\n        if (!newMemory[newPath]) {\n            newMemory[newPath] = { ...initialState };\n            // setFilters({\n            //     ...filters,\n            //     path: newPath,\n            //     headerType: newHeaderType || 'home'\n            // })\n            // setFilters({ ...initialState });\n            console.log(newMemory, initialState, 'state');\n        } else {\n            console.log(newMemory, 'state', '1');\n            return {};\n        }\n    }, [])\n\n    useEffect(() => {\n        window.addEventListener('memoryChange', handleMemoryChange)\n        window.removeEventListener('memoryChange', handleMemoryChange)\n    }, [])\n    console.log(newMemory, 'state', '2');\n    return ;\n}\n\nUseHeaderchange.propTypes = {\n    newPath: PropTypes.string,\n    headerType: PropTypes.string\n}\n\nexport default UseHeaderchange;"]},"metadata":{},"sourceType":"module"}